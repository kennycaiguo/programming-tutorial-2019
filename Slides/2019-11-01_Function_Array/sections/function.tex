\section{函数}\label{sec:函数}

\begin{frame}[fragile]{函数定义}
    通过OJ的练习的联系, 相信大家对函数已经比较熟悉.

    函数结构: \texttt{type name (para1, para2, \ldots) \{ statements \}}

    \begin{itemize}[<+- | alert@+>]
        \item \texttt{type}: 返回值的类型, 没有返回值为\texttt{void}
        \item \texttt{name}: 函数名, 命名规则与变量名相同
        \item \texttt{paras}: 参数列表, 每个参数包含类型和参数名, 用逗号分隔.
        没有参数可以留空, 或用\texttt{void}显式表示参数列表为空
        \item \texttt{statements}: 函数体, 被大括号包围
        \item 举例:
        \begin{lstlisting}[language=c]
int addition(int a, int b) {
    return a + b;
}
        \end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{函数调用}
    函数调用需使用与被调用函数匹配的参数列表

    如果函数有返回值, 可以赋值给匹配的类型, 也可以忽略

    \emptyline
    \begin{lstlisting}[language=c]
int z = addition(5, 3);
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{函数声明}
    如果有多个源代码文件, 或同一文件中函数调用在函数实现之前,
    则编译器看不到被调用函数的信息(参数类型个数, 返回值), 无法进行编译

    这种情况下, 可以对函数进行声明

    函数声明就像把函数体去掉, 换成分号, 比如:
    \begin{lstlisting}[language=c]
int addition(int a, int b);
    \end{lstlisting}

    头文件中应只有声明, 没有定义 (否则一个程序包含多次该头文件将出现重定义错误)
\end{frame}

\begin{frame}[fragile]{递归函数}
    函数可以调用其自身, 隐式地维护了一个栈(后进先出的数据结构), 对有的任务而言非常方便

    如果能用循环实现, 且不需要维护栈的信息, 通常循环效率更高
    \begin{columns}[T,onlytextwidth]
        \column{0.40\textwidth}
        \scriptsize
        \begin{lstlisting}[language=c]
unsigned short
factorial (unsigned short a) {
    if (a > 1)
        return a * factorial(a-1);
    else
        return 1;
}
        \end{lstlisting}

        \column{0.10\textwidth}
        \column{0.50\textwidth}
        \scriptsize
        \begin{lstlisting}[language=c]
unsigned short
factorial_loop(unsigned short a) {
    unsigned short result = a;
    while (--a)
        result *= a;
    return result;
}
        \end{lstlisting}
    \end{columns}

    分别传入参数 -1 调用这两个函数, 会发生什么?
\end{frame}